// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.textanalytics;

import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.http.HttpMethod;
import com.azure.core.http.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;

/**
 * Initializes a new instance of the TextAnalyticsClient type.
 */
@ServiceClient(builder = TextAnalyticsClientBuilder.class)
public final class TextAnalyticsClient {
    private final TextAnalyticsAsyncClient asyncClient;

    /**
     * Initializes an instance of TextAnalyticsClient client.
     * 
     * @param asyncClient The TextAnalyticsAsyncClient underneath.
     */
    TextAnalyticsClient(TextAnalyticsAsyncClient asyncClient) {
        this.asyncClient = asyncClient;
    }

    /**
     * Submit a collection of text documents for analysis. Specify one or more unique tasks to be executed.
     * <p><strong>Request Body Schema</strong></p>
     * <pre>{@code
     * {
     *     displayName: String
     *     analysisInput: {
     *         documents: [
     *             {
     *                 id: String
     *                 text: String
     *                 language: String
     *             }
     *         ]
     *     }
     *     tasks: {
     *         entityRecognitionTasks: [
     *             {
     *                 parameters: {
     *                     modelVersion: String
     *                     stringIndexType: String(TextElements_v8/UnicodeCodePoint/Utf16CodeUnit)
     *                 }
     *             }
     *         ]
     *         entityRecognitionPiiTasks: [
     *             {
     *                 parameters: {
     *                     domain: String(phi/none)
     *                     modelVersion: String
     *                     stringIndexType: String(TextElements_v8/UnicodeCodePoint/Utf16CodeUnit)
     *                 }
     *             }
     *         ]
     *         keyPhraseExtractionTasks: [
     *             {
     *                 parameters: {
     *                     modelVersion: String
     *                 }
     *             }
     *         ]
     *     }
     * }
     * }</pre>
     * 
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> analyzeWithResponse(RequestOptions options, Context context) {
        return asyncClient.analyzeWithResponse(options, context).block();
    }

    /**
     * Get the status of an analysis job.  A job may consist of one or more tasks.  Once all tasks are completed, the job will transition to the completed state and results will be available for each task.
     * <p><strong>Optional Query Parameters</strong></p>
     * <table border="1">
     *     <caption>Optional Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
     *     <tr><td>showStats</td><td>Boolean</td><td>(Optional) if set to true, response will contain request and document level statistics.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>(Optional) Set the maximum number of results per task. When both $top and $skip are specified, $skip is applied first.</td></tr>
     *     <tr><td>skip</td><td>Integer</td><td>(Optional) Set the number of elements to offset in the response. When both $top and $skip are specified, $skip is applied first.</td></tr>
     * </table>
     * <p><strong>Response Body Schema</strong></p>
     * <pre>{@code
     * {
     *     createdDateTime: OffsetDateTime
     *     expirationDateTime: OffsetDateTime
     *     jobId: UUID
     *     lastUpdateDateTime: OffsetDateTime
     *     status: String(notStarted/running/succeeded/failed/rejected/cancelled/cancelling/partiallyCompleted)
     *     displayName: String
     *     errors: [
     *         {
     *             code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/NotFound)
     *             message: String
     *             target: String
     *             innererror: {
     *                 code: String(InvalidParameterValue/InvalidRequestBodyFormat/EmptyRequest/MissingInputRecords/InvalidDocument/ModelVersionIncorrect/InvalidDocumentBatch/UnsupportedLanguageCode/InvalidCountryHint)
     *                 message: String
     *                 details: {
     *                     String: String
     *                 }
     *                 target: String
     *                 innererror: (recursive schema, see innererror above)
     *             }
     *             details: [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     ]
     *     statistics: {
     *         documentsCount: int
     *         validDocumentsCount: int
     *         erroneousDocumentsCount: int
     *         transactionsCount: long
     *     }
     *     tasks: {
     *         details: {
     *             lastUpdateDateTime: OffsetDateTime
     *             name: String
     *             status: String(notStarted/running/succeeded/failed/rejected/cancelled/cancelling/partiallyCompleted)
     *         }
     *         completed: int
     *         failed: int
     *         inProgress: int
     *         total: int
     *         entityRecognitionTasks: [
     *             {
     *                 lastUpdateDateTime: OffsetDateTime
     *                 name: String
     *                 status: String(notStarted/running/succeeded/failed/rejected/cancelled/cancelling/partiallyCompleted)
     *                 results: {
     *                     documents: [
     *                         {
     *                             id: String
     *                             entities: [
     *                                 {
     *                                     text: String
     *                                     category: String
     *                                     subcategory: String
     *                                     offset: int
     *                                     length: int
     *                                     confidenceScore: double
     *                                 }
     *                             ]
     *                             warnings: [
     *                                 {
     *                                     code: String(LongWordsInDocument/DocumentTruncated)
     *                                     message: String
     *                                     targetRef: String
     *                                 }
     *                             ]
     *                             statistics: {
     *                                 charactersCount: int
     *                                 transactionsCount: int
     *                             }
     *                         }
     *                     ]
     *                     errors: [
     *                         {
     *                             id: String
     *                             error: (recursive schema, see error above)
     *                         }
     *                     ]
     *                     statistics: (recursive schema, see statistics above)
     *                     modelVersion: String
     *                 }
     *             }
     *         ]
     *         entityRecognitionPiiTasks: [
     *             {
     *                 lastUpdateDateTime: OffsetDateTime
     *                 name: String
     *                 status: String(notStarted/running/succeeded/failed/rejected/cancelled/cancelling/partiallyCompleted)
     *                 results: {
     *                     documents: [
     *                         {
     *                             id: String
     *                             redactedText: String
     *                             entities: [
     *                                 (recursive schema, see above)
     *                             ]
     *                             warnings: [
     *                                 (recursive schema, see above)
     *                             ]
     *                             statistics: (recursive schema, see statistics above)
     *                         }
     *                     ]
     *                     errors: [
     *                         (recursive schema, see above)
     *                     ]
     *                     statistics: (recursive schema, see statistics above)
     *                     modelVersion: String
     *                 }
     *             }
     *         ]
     *         keyPhraseExtractionTasks: [
     *             {
     *                 lastUpdateDateTime: OffsetDateTime
     *                 name: String
     *                 status: String(notStarted/running/succeeded/failed/rejected/cancelled/cancelling/partiallyCompleted)
     *                 results: {
     *                     documents: [
     *                         {
     *                             id: String
     *                             keyPhrases: [
     *                                 String
     *                             ]
     *                             warnings: [
     *                                 (recursive schema, see above)
     *                             ]
     *                             statistics: (recursive schema, see statistics above)
     *                         }
     *                     ]
     *                     errors: [
     *                         (recursive schema, see above)
     *                     ]
     *                     statistics: (recursive schema, see statistics above)
     *                     modelVersion: String
     *                 }
     *             }
     *         ]
     *     }
     *     nextLink: String
     * }
     * }</pre>
     * 
     * @param jobId Job ID for Analyze.
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> analyzeStatusWithResponse(String jobId, RequestOptions options, Context context) {
        return asyncClient.analyzeStatusWithResponse(jobId, options, context).block();
    }

    /**
     * Get details of the healthcare prediction job specified by the jobId.
     * <p><strong>Optional Query Parameters</strong></p>
     * <table border="1">
     *     <caption>Optional Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
     *     <tr><td>top</td><td>Integer</td><td>(Optional) Set the maximum number of results per task. When both $top and $skip are specified, $skip is applied first.</td></tr>
     *     <tr><td>skip</td><td>Integer</td><td>(Optional) Set the number of elements to offset in the response. When both $top and $skip are specified, $skip is applied first.</td></tr>
     *     <tr><td>showStats</td><td>Boolean</td><td>(Optional) if set to true, response will contain request and document level statistics.</td></tr>
     * </table>
     * <p><strong>Response Body Schema</strong></p>
     * <pre>{@code
     * {
     *     createdDateTime: OffsetDateTime
     *     expirationDateTime: OffsetDateTime
     *     jobId: UUID
     *     lastUpdateDateTime: OffsetDateTime
     *     status: String(notStarted/running/succeeded/failed/rejected/cancelled/cancelling/partiallyCompleted)
     *     results: {
     *         documents: [
     *             {
     *                 id: String
     *                 entities: [
     *                     {
     *                         text: String
     *                         category: String
     *                         subcategory: String
     *                         offset: int
     *                         length: int
     *                         confidenceScore: double
     *                         isNegated: boolean
     *                         links: [
     *                             {
     *                                 dataSource: String
     *                                 id: String
     *                             }
     *                         ]
     *                     }
     *                 ]
     *                 relations: [
     *                     {
     *                         relationType: String
     *                         bidirectional: boolean
     *                         source: String
     *                         target: String
     *                     }
     *                 ]
     *                 warnings: [
     *                     {
     *                         code: String(LongWordsInDocument/DocumentTruncated)
     *                         message: String
     *                         targetRef: String
     *                     }
     *                 ]
     *                 statistics: {
     *                     charactersCount: int
     *                     transactionsCount: int
     *                 }
     *             }
     *         ]
     *         errors: [
     *             {
     *                 id: String
     *                 error: {
     *                     code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/NotFound)
     *                     message: String
     *                     target: String
     *                     innererror: {
     *                         code: String(InvalidParameterValue/InvalidRequestBodyFormat/EmptyRequest/MissingInputRecords/InvalidDocument/ModelVersionIncorrect/InvalidDocumentBatch/UnsupportedLanguageCode/InvalidCountryHint)
     *                         message: String
     *                         details: {
     *                             String: String
     *                         }
     *                         target: String
     *                         innererror: (recursive schema, see innererror above)
     *                     }
     *                     details: [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *             }
     *         ]
     *         statistics: {
     *             documentsCount: int
     *             validDocumentsCount: int
     *             erroneousDocumentsCount: int
     *             transactionsCount: long
     *         }
     *         modelVersion: String
     *     }
     *     errors: [
     *         (recursive schema, see above)
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     * 
     * @param jobId Job ID.
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> healthStatusWithResponse(String jobId, RequestOptions options, Context context) {
        return asyncClient.healthStatusWithResponse(jobId, options, context).block();
    }

    /**
     * Cancel healthcare prediction job.
     * 
     * @param jobId Job ID.
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> cancelHealthJobWithResponse(String jobId, RequestOptions options, Context context) {
        return asyncClient.cancelHealthJobWithResponse(jobId, options, context).block();
    }

    /**
     * Start a healthcare analysis job to recognize healthcare related entities (drugs, conditions, symptoms, etc) and their relations.
     * <p><strong>Optional Query Parameters</strong></p>
     * <table border="1">
     *     <caption>Optional Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
     *     <tr><td>modelVersion</td><td>String</td><td>(Optional) This value indicates which model will be used for scoring. If a model-version is not specified, the API should default to the latest, non-preview version. </td></tr>
     *     <tr><td>stringIndexType</td><td>StringIndexType</td><td>(Optional) Specifies the method used to interpret string offsets.  Defaults to Text Elements (Graphemes) according to Unicode v8.0.0. For additional information see https://aka.ms/text-analytics-offsets</td></tr>
     * </table>
     * <p><strong>Request Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             text: String
     *             language: String
     *         }
     *     ]
     * }
     * }</pre>
     * 
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> healthWithResponse(BinaryData input, RequestOptions options, Context context) {
        return asyncClient.healthWithResponse(input, options, context).block();
    }

    /**
     * The API returns a list of general named entities in a given document. For the list of supported entity types, check &lt;a href="https://aka.ms/taner"&gt;Supported Entity Types in Text Analytics API&lt;/a&gt;. See the &lt;a href="https://aka.ms/talangs"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     * <p><strong>Optional Query Parameters</strong></p>
     * <table border="1">
     *     <caption>Optional Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
     *     <tr><td>modelVersion</td><td>String</td><td>(Optional) This value indicates which model will be used for scoring. If a model-version is not specified, the API should default to the latest, non-preview version. </td></tr>
     *     <tr><td>showStats</td><td>Boolean</td><td>(Optional) if set to true, response will contain request and document level statistics.</td></tr>
     *     <tr><td>stringIndexType</td><td>StringIndexType</td><td>(Optional) Specifies the method used to interpret string offsets.  Defaults to Text Elements (Graphemes) according to Unicode v8.0.0. For additional information see https://aka.ms/text-analytics-offsets</td></tr>
     * </table>
     * <p><strong>Request Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             text: String
     *             language: String
     *         }
     *     ]
     * }
     * }</pre>
     * <p><strong>Response Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             entities: [
     *                 {
     *                     text: String
     *                     category: String
     *                     subcategory: String
     *                     offset: int
     *                     length: int
     *                     confidenceScore: double
     *                 }
     *             ]
     *             warnings: [
     *                 {
     *                     code: String(LongWordsInDocument/DocumentTruncated)
     *                     message: String
     *                     targetRef: String
     *                 }
     *             ]
     *             statistics: {
     *                 charactersCount: int
     *                 transactionsCount: int
     *             }
     *         }
     *     ]
     *     errors: [
     *         {
     *             id: String
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/NotFound)
     *                 message: String
     *                 target: String
     *                 innererror: {
     *                     code: String(InvalidParameterValue/InvalidRequestBodyFormat/EmptyRequest/MissingInputRecords/InvalidDocument/ModelVersionIncorrect/InvalidDocumentBatch/UnsupportedLanguageCode/InvalidCountryHint)
     *                     message: String
     *                     details: {
     *                         String: String
     *                     }
     *                     target: String
     *                     innererror: (recursive schema, see innererror above)
     *                 }
     *                 details: [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *         }
     *     ]
     *     statistics: {
     *         documentsCount: int
     *         validDocumentsCount: int
     *         erroneousDocumentsCount: int
     *         transactionsCount: long
     *     }
     *     modelVersion: String
     * }
     * }</pre>
     * 
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> entitiesRecognitionGeneralWithResponse(BinaryData input, RequestOptions options, Context context) {
        return asyncClient.entitiesRecognitionGeneralWithResponse(input, options, context).block();
    }

    /**
     * The API returns a list of entities with personal information (\"SSN\", \"Bank Account\" etc) in the document. For the list of supported entity types, check &lt;a href="https://aka.ms/tanerpii"&gt;Supported Entity Types in Text Analytics API&lt;/a&gt;. See the &lt;a href="https://aka.ms/talangs"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     * <p><strong>Optional Query Parameters</strong></p>
     * <table border="1">
     *     <caption>Optional Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
     *     <tr><td>modelVersion</td><td>String</td><td>(Optional) This value indicates which model will be used for scoring. If a model-version is not specified, the API should default to the latest, non-preview version. </td></tr>
     *     <tr><td>showStats</td><td>Boolean</td><td>(Optional) if set to true, response will contain request and document level statistics.</td></tr>
     *     <tr><td>domain</td><td>String</td><td>(Optional) if specified, will set the PII domain to include only a subset of the entity categories. Possible values include: 'PHI', 'none'.</td></tr>
     *     <tr><td>stringIndexType</td><td>StringIndexType</td><td>(Optional) Specifies the method used to interpret string offsets.  Defaults to Text Elements (Graphemes) according to Unicode v8.0.0. For additional information see https://aka.ms/text-analytics-offsets</td></tr>
     * </table>
     * <p><strong>Request Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             text: String
     *             language: String
     *         }
     *     ]
     * }
     * }</pre>
     * <p><strong>Response Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             redactedText: String
     *             entities: [
     *                 {
     *                     text: String
     *                     category: String
     *                     subcategory: String
     *                     offset: int
     *                     length: int
     *                     confidenceScore: double
     *                 }
     *             ]
     *             warnings: [
     *                 {
     *                     code: String(LongWordsInDocument/DocumentTruncated)
     *                     message: String
     *                     targetRef: String
     *                 }
     *             ]
     *             statistics: {
     *                 charactersCount: int
     *                 transactionsCount: int
     *             }
     *         }
     *     ]
     *     errors: [
     *         {
     *             id: String
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/NotFound)
     *                 message: String
     *                 target: String
     *                 innererror: {
     *                     code: String(InvalidParameterValue/InvalidRequestBodyFormat/EmptyRequest/MissingInputRecords/InvalidDocument/ModelVersionIncorrect/InvalidDocumentBatch/UnsupportedLanguageCode/InvalidCountryHint)
     *                     message: String
     *                     details: {
     *                         String: String
     *                     }
     *                     target: String
     *                     innererror: (recursive schema, see innererror above)
     *                 }
     *                 details: [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *         }
     *     ]
     *     statistics: {
     *         documentsCount: int
     *         validDocumentsCount: int
     *         erroneousDocumentsCount: int
     *         transactionsCount: long
     *     }
     *     modelVersion: String
     * }
     * }</pre>
     * 
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> entitiesRecognitionPiiWithResponse(BinaryData input, RequestOptions options, Context context) {
        return asyncClient.entitiesRecognitionPiiWithResponse(input, options, context).block();
    }

    /**
     * The API returns a list of recognized entities with links to a well-known knowledge base. See the &lt;a href="https://aka.ms/talangs"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     * <p><strong>Optional Query Parameters</strong></p>
     * <table border="1">
     *     <caption>Optional Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
     *     <tr><td>modelVersion</td><td>String</td><td>(Optional) This value indicates which model will be used for scoring. If a model-version is not specified, the API should default to the latest, non-preview version. </td></tr>
     *     <tr><td>showStats</td><td>Boolean</td><td>(Optional) if set to true, response will contain request and document level statistics.</td></tr>
     *     <tr><td>stringIndexType</td><td>StringIndexType</td><td>(Optional) Specifies the method used to interpret string offsets.  Defaults to Text Elements (Graphemes) according to Unicode v8.0.0. For additional information see https://aka.ms/text-analytics-offsets</td></tr>
     * </table>
     * <p><strong>Request Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             text: String
     *             language: String
     *         }
     *     ]
     * }
     * }</pre>
     * <p><strong>Response Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             entities: [
     *                 {
     *                     name: String
     *                     matches: [
     *                         {
     *                             confidenceScore: double
     *                             text: String
     *                             offset: int
     *                             length: int
     *                         }
     *                     ]
     *                     language: String
     *                     id: String
     *                     url: String
     *                     dataSource: String
     *                     bingId: String
     *                 }
     *             ]
     *             warnings: [
     *                 {
     *                     code: String(LongWordsInDocument/DocumentTruncated)
     *                     message: String
     *                     targetRef: String
     *                 }
     *             ]
     *             statistics: {
     *                 charactersCount: int
     *                 transactionsCount: int
     *             }
     *         }
     *     ]
     *     errors: [
     *         {
     *             id: String
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/NotFound)
     *                 message: String
     *                 target: String
     *                 innererror: {
     *                     code: String(InvalidParameterValue/InvalidRequestBodyFormat/EmptyRequest/MissingInputRecords/InvalidDocument/ModelVersionIncorrect/InvalidDocumentBatch/UnsupportedLanguageCode/InvalidCountryHint)
     *                     message: String
     *                     details: {
     *                         String: String
     *                     }
     *                     target: String
     *                     innererror: (recursive schema, see innererror above)
     *                 }
     *                 details: [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *         }
     *     ]
     *     statistics: {
     *         documentsCount: int
     *         validDocumentsCount: int
     *         erroneousDocumentsCount: int
     *         transactionsCount: long
     *     }
     *     modelVersion: String
     * }
     * }</pre>
     * 
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> entitiesLinkingWithResponse(BinaryData input, RequestOptions options, Context context) {
        return asyncClient.entitiesLinkingWithResponse(input, options, context).block();
    }

    /**
     * The API returns a list of strings denoting the key phrases in the input text. See the &lt;a href="https://aka.ms/talangs"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     * <p><strong>Optional Query Parameters</strong></p>
     * <table border="1">
     *     <caption>Optional Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
     *     <tr><td>modelVersion</td><td>String</td><td>(Optional) This value indicates which model will be used for scoring. If a model-version is not specified, the API should default to the latest, non-preview version. </td></tr>
     *     <tr><td>showStats</td><td>Boolean</td><td>(Optional) if set to true, response will contain request and document level statistics.</td></tr>
     * </table>
     * <p><strong>Request Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             text: String
     *             language: String
     *         }
     *     ]
     * }
     * }</pre>
     * <p><strong>Response Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             keyPhrases: [
     *                 String
     *             ]
     *             warnings: [
     *                 {
     *                     code: String(LongWordsInDocument/DocumentTruncated)
     *                     message: String
     *                     targetRef: String
     *                 }
     *             ]
     *             statistics: {
     *                 charactersCount: int
     *                 transactionsCount: int
     *             }
     *         }
     *     ]
     *     errors: [
     *         {
     *             id: String
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/NotFound)
     *                 message: String
     *                 target: String
     *                 innererror: {
     *                     code: String(InvalidParameterValue/InvalidRequestBodyFormat/EmptyRequest/MissingInputRecords/InvalidDocument/ModelVersionIncorrect/InvalidDocumentBatch/UnsupportedLanguageCode/InvalidCountryHint)
     *                     message: String
     *                     details: {
     *                         String: String
     *                     }
     *                     target: String
     *                     innererror: (recursive schema, see innererror above)
     *                 }
     *                 details: [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *         }
     *     ]
     *     statistics: {
     *         documentsCount: int
     *         validDocumentsCount: int
     *         erroneousDocumentsCount: int
     *         transactionsCount: long
     *     }
     *     modelVersion: String
     * }
     * }</pre>
     * 
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> keyPhrasesWithResponse(BinaryData input, RequestOptions options, Context context) {
        return asyncClient.keyPhrasesWithResponse(input, options, context).block();
    }

    /**
     * The API returns the detected language and a numeric score between 0 and 1. Scores close to 1 indicate 100% certainty that the identified language is true. See the &lt;a href="https://aka.ms/talangs"&gt;Supported languages in Text Analytics API&lt;/a&gt; for the list of enabled languages.
     * <p><strong>Optional Query Parameters</strong></p>
     * <table border="1">
     *     <caption>Optional Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
     *     <tr><td>modelVersion</td><td>String</td><td>(Optional) This value indicates which model will be used for scoring. If a model-version is not specified, the API should default to the latest, non-preview version. </td></tr>
     *     <tr><td>showStats</td><td>Boolean</td><td>(Optional) if set to true, response will contain request and document level statistics.</td></tr>
     * </table>
     * <p><strong>Request Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             text: String
     *             countryHint: String
     *         }
     *     ]
     * }
     * }</pre>
     * <p><strong>Response Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             detectedLanguage: {
     *                 name: String
     *                 iso6391Name: String
     *                 confidenceScore: double
     *             }
     *             warnings: [
     *                 {
     *                     code: String(LongWordsInDocument/DocumentTruncated)
     *                     message: String
     *                     targetRef: String
     *                 }
     *             ]
     *             statistics: {
     *                 charactersCount: int
     *                 transactionsCount: int
     *             }
     *         }
     *     ]
     *     errors: [
     *         {
     *             id: String
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/NotFound)
     *                 message: String
     *                 target: String
     *                 innererror: {
     *                     code: String(InvalidParameterValue/InvalidRequestBodyFormat/EmptyRequest/MissingInputRecords/InvalidDocument/ModelVersionIncorrect/InvalidDocumentBatch/UnsupportedLanguageCode/InvalidCountryHint)
     *                     message: String
     *                     details: {
     *                         String: String
     *                     }
     *                     target: String
     *                     innererror: (recursive schema, see innererror above)
     *                 }
     *                 details: [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *         }
     *     ]
     *     statistics: {
     *         documentsCount: int
     *         validDocumentsCount: int
     *         erroneousDocumentsCount: int
     *         transactionsCount: long
     *     }
     *     modelVersion: String
     * }
     * }</pre>
     * 
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> languagesWithResponse(BinaryData input, RequestOptions options, Context context) {
        return asyncClient.languagesWithResponse(input, options, context).block();
    }

    /**
     * The API returns a detailed sentiment analysis for the input text. The analysis is done in multiple levels of granularity, start from the a document level, down to sentence and key terms (aspects) and opinions.
     * <p><strong>Optional Query Parameters</strong></p>
     * <table border="1">
     *     <caption>Optional Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Description</th></tr>
     *     <tr><td>modelVersion</td><td>String</td><td>(Optional) This value indicates which model will be used for scoring. If a model-version is not specified, the API should default to the latest, non-preview version. </td></tr>
     *     <tr><td>showStats</td><td>Boolean</td><td>(Optional) if set to true, response will contain request and document level statistics.</td></tr>
     *     <tr><td>opinionMining</td><td>Boolean</td><td>(Optional) if set to true, response will contain input and document level statistics including aspect-based sentiment analysis results.</td></tr>
     *     <tr><td>stringIndexType</td><td>StringIndexType</td><td>(Optional) Specifies the method used to interpret string offsets.  Defaults to Text Elements (Graphemes) according to Unicode v8.0.0. For additional information see https://aka.ms/text-analytics-offsets</td></tr>
     * </table>
     * <p><strong>Request Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             text: String
     *             language: String
     *         }
     *     ]
     * }
     * }</pre>
     * <p><strong>Response Body Schema</strong></p>
     * <pre>{@code
     * {
     *     documents: [
     *         {
     *             id: String
     *             sentiment: String(positive/neutral/negative/mixed)
     *             statistics: {
     *                 charactersCount: int
     *                 transactionsCount: int
     *             }
     *             confidenceScores: {
     *                 positive: double
     *                 neutral: double
     *                 negative: double
     *             }
     *             sentences: [
     *                 {
     *                     text: String
     *                     sentiment: String(positive/neutral/negative)
     *                     confidenceScores: (recursive schema, see confidenceScores above)
     *                     offset: int
     *                     length: int
     *                     aspects: [
     *                         {
     *                             sentiment: String(positive/mixed/negative)
     *                             confidenceScores: {
     *                                 positive: double
     *                                 negative: double
     *                             }
     *                             offset: int
     *                             length: int
     *                             text: String
     *                             relations: [
     *                                 {
     *                                     relationType: String(opinion/aspect)
     *                                     ref: String
     *                                 }
     *                             ]
     *                         }
     *                     ]
     *                     opinions: [
     *                         {
     *                             sentiment: String(positive/mixed/negative)
     *                             confidenceScores: (recursive schema, see confidenceScores above)
     *                             offset: int
     *                             length: int
     *                             text: String
     *                             isNegated: boolean
     *                         }
     *                     ]
     *                 }
     *             ]
     *             warnings: [
     *                 {
     *                     code: String(LongWordsInDocument/DocumentTruncated)
     *                     message: String
     *                     targetRef: String
     *                 }
     *             ]
     *         }
     *     ]
     *     errors: [
     *         {
     *             id: String
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/NotFound)
     *                 message: String
     *                 target: String
     *                 innererror: {
     *                     code: String(InvalidParameterValue/InvalidRequestBodyFormat/EmptyRequest/MissingInputRecords/InvalidDocument/ModelVersionIncorrect/InvalidDocumentBatch/UnsupportedLanguageCode/InvalidCountryHint)
     *                     message: String
     *                     details: {
     *                         String: String
     *                     }
     *                     target: String
     *                     innererror: (recursive schema, see innererror above)
     *                 }
     *                 details: [
     *                     (recursive schema, see above)
     *                 ]
     *             }
     *         }
     *     ]
     *     statistics: {
     *         documentsCount: int
     *         validDocumentsCount: int
     *         erroneousDocumentsCount: int
     *         transactionsCount: long
     *     }
     *     modelVersion: String
     * }
     * }</pre>
     * 
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> sentimentWithResponse(BinaryData input, RequestOptions options, Context context) {
        return asyncClient.sentimentWithResponse(input, options, context).block();
    }

    /**
     * Create an empty DynamicRequest with the serializer and pipeline initialized for this client.
     * 
     * @return a DynamicRequest where customizations can be made before sent to the service.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> invoke(String url, HttpMethod httpMethod, BinaryData body, RequestOptions options, Context context) {
        return asyncClient.invoke(url, httpMethod, body, options, context).block();
    }
}
